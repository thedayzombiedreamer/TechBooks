# Chapter 6 : 버전 스탬프

* 트랜잭션 관리 - 버전 스탬프(version stamp)로 대처한다.
* 낙관적 오프라인 잠금 : 트랜잭션을 커밋하기 전에 트랜잭션에서 사용하는 정보가 처음 읽어 사용자에게 표시한 시점 이후로 변경되지 않았는지 ‘다시 한 번’ 읽어 확인하는 방법.
* Web 에서의 etag를 사용하는 기법과 동일하다. etag는 리소스 버전을 나타내는 문자열이고, 조건적 업데이트를 할 수 있다. 
* 일부 데이터베이스에서는 낡은 데이터를 기반으로 업데이트를 하지 않도록 조건적 업데이트와 비슷한 메커니즘을 제공할 수 있으나, 다른 스레드가 해당 자원에 접근하지 못하도록 보장해야 한다 (이 방법을 CAS(Compare-And-Set) 연산이라고 부르는데, 프로세서에서 실행되는 CAS 연산의 이름에서 따온 것)

* 버전 스탬프를 만들 수 있는 다양한 방법 
    * 카운터 - 가장 간단하지만, 카운터값이 중복되지 않도록 생성하려면 단일 마스터가 필요.
    * GUID (유일성이 보장되는 큰 난수) 를 생성. 크기가 크고 어떤 값이 최신 값인지 비교가 불가능하다는 단점이 있다.
    * 컨텐츠 기반 해시 생성.
    * 마지막 업데이트의 타임스탬프를 사용하는 것. 제대로 생성하기 위해선 각 노드의 시간을 동기화해야 한다.
    * 두 가지 방법을 조합해서 사용할 수 있다.
    * 다중 노드 시스템에서의 버전 스탬프는 타임스탬프가 더 많은 문제를 야기할 수 있다. 노드의 시간을 똑같이 맞춰야 하는 부분이나 쓰기 충돌을 탐지할 수 없거나. 차라리 카운터가 낫다.
    * Peer-to-Peer NoSQL 시스템에서 흔하게 사용하는 방법은 ‘벡터 스탬프’라는 특별한 형태의 버전 스탬프이다.
    * 벡터 스탬프는 각 노드의 카운터로 구성된 카운터의 집합이다. 각 노드에 대한 스탬프 값을 유지하고 있는 것이다. 이 방법으로 최신 버전을 알 수 있고, 쓰기 충돌을 감지할 수 있다. 비일관성을 발견하는 데는 요긴하지만, 비일관성을 해결하지는 못한다.


# Chapter 7 : Map-Reduce

집합 지향 데이터베이스가 주목받는 이유 중 상당 부분은 클러스터의 성장에 기인한다. 클러스터에서 실행한다는 것의 의미는 데이터를 저장하는 데 있어 단일 장비에서 실행할 때와는 다른 방식의 기술적 타협이 필요함을 뜻한다. 저장 규칙 / 처리 규칙 모두 다르게 생각해야 한다.

* 중앙 집중형 데이터베이스 : 데이터베이스 서버에서 직접 처리하거나 클라이언트 장비에서 처리.
* 클러스터 환경 : 작업을 퍼뜨릴 장비가 많다. 데이터처리를 할 때, 가능한 필요 데이터가 위치한 노드에서 작업을 수행해 네트워크 사용량을 줄이는 노력이 필요.

맵-리듀스 패턴(Scatter-Gather의 한 형태)은 클러스터에서 많은 장비의 장점을 활용해 처리하면서 데이터가 위치한 노드에서 최대한 많은 처리가 실행되도록 작업을 조직하는 방법이다.
흔히 우리가 알고 있는 맵-리듀스를 의미하는데, 여러 노드에서 수행한 맵 작업의 결과를 모두 모아 하나의 리듀스로 보내는 것보다 효율적인 방법을 생각해보자.

* 맵 작업 결과를 파티션으로 나눠 병렬성을 늘린다. 각 리듀스 함수는 키 하나에 대해서만 작용한다.  각 노드의 결과를 키별로 나누고 나면, 보통 여러 개 키가 파티션으로 묶인다. 그리고 나서 모든 노드로부터 하나의 파티션에 대한 데이터를 가져다 해당 파티션에 대한 하나의 그룹으로 결합한 다음, 리듀스 함수로 보낸다.
* 맵과 리듀스 단계 사이에서 노드간 이동하는 데이터량을 줄인다. 결합 함수를 통해서 똑같은 키에 대한 데이터를 값 하나로 결합해서 데이터 크기를 줄인다. Combinable Reducer - 출력이 입력과 연결되어야 한다.

맵은 한 집합에 대해서만 적용할 수 있고, 리듀스 작업은 한 키에 대해서만 적용할 수 있다. 이런 제약 조건에서도 잘 동작하게 하려면 프로그램의 구조를 다르게 생각해야 한다. 이것은 동시 처리에 대한 사고방식이다. 병렬화하기 위해 단순한 모델의 균형을 유지한다. 두 개의 그룹의 주문에서 제품별 평균 주문 수량을 알고 싶다고 했을 때, 각 그룹의 평균 값을 더한들 평균이 나오지 않는다. 이 때는 제품 갯수와 주문 수량을 함께 반환해서 결합된 수량과 건수로 계산한다.
파이프와 필터를 사용해서 작업을 여러 단계로 나눌 수 있다. 
맵-리듀스 계산은 클러스터 환경에서 실행하더라도 시간이 걸리는 경우가 많다. 새로운 데이터는 계소개서 들어오기 때문에 최신 결과를 유지하려면 계산을 계속해서 재실행해야 한다. 매번 처음부터 다시 시작하면 시간이 너무 오래 걸리므로, 점증적 업데이트가 되도록 맵-리듀스 계산 구조를 만들어 계산을 최소화하는 것이 좋다.

# Chapter 8 : Key-Value

간단한 해시 테이블로, 주키(PK)를 통해서만 데이터베이스에 접근할 때 사용한다. 클라이언트는 키에 대한 값을 얻거나, 키에 대한 값을 넣을 수 있고, 데이터 저장소에서 키를 삭제할 수 있다. 값은 BLOB(Binary Large OBject)로 데이터 저장소는 값을 저장할 뿐, 값의 내부를 알지도 못하고 신경 쓰지도 않는다.
일관성을 가져가기 위한 전략이 필요하다. 
많은 데이터 저장소가 트랜잭션을 다른 방식으로 구현한다. 리악은 정족수 개념을 사용하도록 구현했다.
Key를 설계하는데 고민을 많이 해야 한다. 설계된 원칙으로 값을 꺼내오므로, 어떻게 유추해야 할 지 고려를 해서 결정한다.
많은 키-값 저장소가 샤딩을 사용해서 확장한다. 샤딩을 사용하면 키 값에 따라 어느 노드에 키를 저장할 지 결정된다.

적절한 사용 : 
* 세션 정보 저장 - 세션에 대한 모든 정보가 한 객체로 저장되어 있으므로, 이런 유형의 단일 요청 연산은 매우 빠르게 수행된다.
* 사용자 프로파일, 설정 - 
* 장바구니 데이터 - UserId를 키로 하고, 모든 쇼핑 정보를 묶어 저장할 수 있다.

적절하지 못한 사용 : 
* 데이터 간의 관계가 있는 경우 - 일부 키-값 저장소가 링크 순회 기능을 지원하지만, 다른 데이터 집합 사이에 관계가 필요하거나 상관관계가 있을 경우 최적의 해법이 아님.
* 다중 연산 트랜잭션을 사용하는 경우 - 여러 개 키를 저장하는 중 하나라도 실패하는 경우, 다른 연산도 되돌리거나 취소해야 하는 경우가 발생한다면 최적의 해법이 아님.
* 데이터로 조회하는 경우 - 값 부분에 있는 어떤 값으로 키를 검색할 필요가 있다면, 원하는대로 사용하기가 어려울 것.
* 집합에 의한 연산 - 연산이 한 번에 키 하나로 제한되므로, 동시에 여러 키에 연산을 수행할 수 없다. 여러 키에 연산을 하려면 클라이언트 쪽에서 처리해야 한다.


# Chapter 9 : Document

문서 데이터베이스는 문서를 저장하고 조회한다. 문서는 XML, JSON, BSON 등이 될 수 있다. 문서는 맵이나 컬렉션, 스칼라 값을 포함할 수 있는 자체 기술적(self-describing), 계층적 트리 데이터 구조이다. 키-값 저장소의 값 부분에 문서를 저장한다. 값을 검사할 수 있는 키-값 저장소라 생각해도 무방하다. 
일관성을 유지하기 위해 복제본 집합(replica set)을 사용해 일관성 수준을 설정하며, 쓰기가 모든 슬레이브에 복제될 때까지 기다릴지, 혹은 주어진 수의 슬레이브에 복제될 때까지만 기다릴 지 선택할 수 있다. 
RDBMS의 트랜잭션란 CRUD 이후, commit이나 rollback을 통해서 변경 사항을 유지할지 말지 결정할 수 있게 하는 기능이다.  일반적으로 NoSQL 솔루션에서 유효하지 않다. 단일 문서 수준에서 트랜잭션은 원자적 트랜잭션이고, 여러 연산에 걸친 트랜잭션을 지원하지 않는다. (지원하는 제품도 있긴 하지만…) 모든 쓰기는 성공이라 보고하는게 기본 동작.
CAP 정리에 따르면, 두 가지 속성만 선택할 수 있다. 문서 데이터베이스는 M-S 설정으로 데이터를 복제해 가용성을 높이려고 한다. 같은 데이터가 여러 노드에 있고 클라이언트는 M노드가 다운된 경우에도 데이터에 접근할 수 있다. 즉 복제본 집합을 사용해 고가용성을 제공한다. 
문서 데이터베이스는 다른 조회 기능을 제공한다. 카우치DB에서는 뷰를 통한 쿼리가 가능하고, 문서에 대한 복잡한 쿼리는 구체화되거나 동적으로 실행될 수 있다. 키-값 저장소와 비교했을 때 문서 데이터베이스가 좋은 점 중 하나는, 키로 문서 전체를 꺼내 내부를 검사하지 않고도 문서 안쪽에 있는 데이터를 조회할 수 있다는 점이다. RDBMS의 쿼리 모델과 가깝다고 할 수 있다. 

더 좋은 장비로 데이터베이스를 이관하는 확장성이 아닌, 노드를 추가하거나 데이터 스토리지를 변경하는 확장성에 대해서 생각해 보자. 읽기 부하에 대한 확장성은 읽기 S노드를 추가해서 해당 슬레이브에서 읽기 요청을 처리하도록 한다. 쓰기 확장성이 필요한 경우, 데이터 샤딩을 할 수 있다. 샤딩은 특정 RDBMS의 파티션과 비슷하다. 즉 특정 칼럼 값을 이용해 데이터를 분할하는 것인데, 보통 파티션을 같은 노드에 위치하도록 한다. 샤딩 또한 특정 필드로 데이터를 분할하지만, 분할된 데이터는 다른 몽고 노드로 이동한다. 샤드 키의 역할은 매우 중요하다.
샤드 클러스터가 복제본 집합을 포함하게 된다. 

적절한 사용 :
* 이벤트 로깅 - 특정 이벤트로부터 잡아내는 데이터 형태가 지속적으로 변하는 경우 / 애플리케이션마다 이벤트 로깅 요건이 다른 경우.
* 콘텐츠 관리 시스템, 블로깅 플랫폼 - 미리 정의한 스키마가 없고 보통 JSON을 이해하기 때문에 콘텐츠 관리 시스템과 잘 맞는다. 
* 웹 분석 또는 실시간 분석 - 문서의 일부를 업데이트할 수 있으므로 페이지 뷰나 고유 방문자를 저장하기 쉽고, 스키마 변경없이 쉽게 새로운 측정 기준을 추가할 수 있다.
* 전자상거래 애플리케이션 - DB 리팩토링이나 데이터 전환은 전자상거래 애플리케이션에서 비용이 많이 드는 부분. 이런 변경 없에 영향없이 데이터 모델을 발전시켜 나갈 수 있다.

적절하지 못한 사용 :
* 여러 연산에 걸친 복잡한 트랜잭션 - 여러 문서에 걸친 연산을 원자적으로 처리해야 하는 경우.
* 변화하는 집합 구조에 대한 쿼리 - 데이터가 Entity 형태로 저장될텐데 이런 Entity를 조회하기 위한 쿼리가 계속 바뀌어야 하는 경우. 즉 집합 구조의 설계가 계속 바뀐다면 집합 구조를 세분하지 않은 형태로 저장해야 한다. 혹은 기본적으로 데이터를 정규화할 필요가 있다. 이런 시나리오에서는 적합하지 않다.


# Chapter 10 : Column Family
칼럼 패밀리 저장소에서는 키가 값에 대응되는 데이터를 저장한다. 값은 여러 개의 칼럼 패밀리로 나뉘는데 각 칼럼 패밀리는 데이터의 맵이 된다. Cassandra 중심으로 설명.
칼럼 패밀리에 행으로 데이터를 저장한다. 행에는 행의 키에 연관된 많은 칼럼이 있다. 칼럼 패밀리는 관련된 데이터의 집단으로 보통 함께 접근된다. 클러스터에 M노드가 필요하지 않으므로 클러스터의 어느 노드에서든 읽기와 쓰기 요청을 처리할 수 있다.
카산드라에서 칼럼은 이름-값의 쌍으로 되어 있고, 이름은 키로 동작한다. 각 키-값 쌍이 한 컬럼이며 항상 타임스탬프 값이 함께 저장된다. 타임스탬프는 데이터 소멸, 쓰기 충돌 해결, 낡은 데이터 처리 등에 사용된다. 칼럼 데이터가 더 이상(…?) 사용되지 않으면 해당 공간은 컴팩션 단계에서 회수될 수 있다.

표준 칼럼 패밀리 : 칼럼 패밀리 안의 칼럼이 간단한 칼럼. (간단한 - 의 기준은?)
칼럼 패밀리는 RDBMS의 테이블에 비유할 수 있는데, 차이점이 있다면 

1) 각 행이 같은 칼럼을 가지지 않아도 된다는 점
2) 다른 행에 영향을 주지 않고 언제든 행에 칼럼을 추가할 수 있다는 점

슈퍼 칼럼 : 칼럼이 칼럼의 맵으로 구성되어 있는 것. 즉 칼럼을 담는 그릇이라고 할 수 있다. 
슈퍼 칼럼 패밀리 : 칼럼 패밀리에 슈퍼 칼럼이 있는 것.

슈퍼 칼럼 패밀리는 관련된 데이터를 저장하는데 유용하지만, 카산드라는 항상 모든 칼럼을 꺼내 역직렬화하므로 일부 칼럼을 사용하지 않는 경우가 많다면 최적은 아니다. 카산드라는 표준 칼럼 패밀리와 슈퍼 칼럼 패밀리를 키스페이스(keyspace)에 넣는다. 키스페이스는 모든 칼럼 패밀리가 저장되는 곳이다.
일관성 유지를 위해 쓰기 요청을 받을 땐, 데이터를 먼저 커밋 로그에 기록하고 그 다음 멤테이블(memtable)이라는 메모리 내 구조에 쓴다. 커밋 로그와 멤테이블에 기록하면 쓰기 연산은 성공으로 간주한다. 쓰기 결과는 메모리 안에 쌓아두었다가 주기적으로  SSTable이란 구조에 기록한다. 한 번 플러시된 SSTable은 수정이 불가능하며 다시 기록하지 않는다. (그럼 두 번 쓰기 요청이 들어온 트랜잭션이나, 같은 데이터에 대한 쓰기 트랜잭션이 두 번 이상 들어오면?) 데이터가 수정되면 새로운 SSTable을 생성해 기록하고, 사용되지 않는 SSTable은 컴팩션 시 회수.

일관성 단계가 있는데 ONE / QUORUM / ALL 이라는 단계로 구분할 수 있다. Poll 방식이라고 판단. 키스페이스를 새엉할 때 복제본이 몇 개 필요한지 설정할 수 있다. 힌티드 핸드오프(hinted handoff)라는 기법을 이용해 다운된 노드가 발생하고 복구된 이후, 유실되었던 데이터를 다른 노드로부터 전달받을 수 있다. 빠르게 복원이 가능하다.
전통적 의미의 트랜잭션은 지원하지 않고 행 단위로 원자적인 쓰기를 지원한다. 특정 행에 대해 칼럼을 삽입하거나 갱신하는 것은 하나의 쓰기로 취급되고 전체가 성공하거나 실패할 것임을 뜻한다. 읽기와 쓰기를 동기화하기 위해 주키퍼ZooKeeper같은 외부 트랜잭션 라이브러리를 사용할 수도 있다. 

카산드라 클러스터에서는 마스터가 없어 모든 노드가 동등하므로 가용성이 높다. 가용성을 지배하는 공식은 
(R + W) > N, 

* R : 읽기에 성공으로 응답해야 하는 최소 노드수 
* W : 쓰기에 성공으로 응답해야 하는 최소 노드수
* N : 데이터 복제에 참여하는 노드 수

쓰기 가용성을 높일지, 읽기 가용성을 높일지, 필요에 따라 키스페이스와 읽기/쓰기 연산의 설정을 조정해야 한다. R=2, W=1인 상황에서 두 노드가 다운되면 
2 + 1 > 3 이라서 쓰기는 가능하지만 읽기는 불가능. R=1, W=2 인 상황에선 반대로 읽기는 가능하지만 쓰기는 불가능.

질의어가 풍부하지 않고, 데이터가 칼럼 패밀리에 삽입될 때 각 행의 데이터가 칼럼 이름으로 정렬되어 들어간다. 따라서 데이터 모델을 설계할 때, 칼럼과 칼럼 패밀리가 읽기에 최적화되도록 설계하는 것이 좋다. 기본 쿼리/고급 쿼리/인덱싱이 존재하는데 SKIP. 카산드라 쿼리 언어 (CQL)를 지원해서 SQL과 비슷하게 질의어를 작성할 수 있지만, 서브쿼리나 조인은 지원하지 않는다.
클러스터를 확장하기 위해선 노드만 더 추가하면 된다. 단일 마스터 노드라는 개념은 없고, 따라서 노드를 추가하면 더 많은 읽기와 쓰기를 지원할 수 있게 클러스터의 능력(?)이 향상된다. 

적절한 사용 :
* 이벤트 로깅 - 어떤 데이터 구조든 저장할 수 있기 때문. 쓰기에 대한 확장도 가능하므로 이상적이라고 판단.
* 콘텐츠 관리 시스템, 블로깅 플랫폼 - 블로그 항목 저장시 태그, 카테고리, 링크, 트랙백도 다른 칼럼에 저장할 수 있다. 댓글은 같은 행에 저장하거나 다른 키스페이스로 옮길 수도 있다.
* 카운터 - 페이지 방문자 수를 세거나 분류할 경우.
* 기간 만료 - 특정 시간 동안만 광고를 표시하는 등의 상황. 기간만료칼럼을 사용해서 이런 작업을 쉽게 할 수 있다. 카산드라에서 미리 정한 시간이 지난 다음에 자동으로 삭제되는 칼럼을 만들 수 있는데 TTL에 정해진 시간이 지난 다음 삭제된다. 해당 칼럼이 존재하지 않으면 권한 회수 혹은 배너 광고를 삭제할 수 있겠다.

적절하지 않은 사용 : 
* 읽기와 쓰기에 대해 ACID 트랜잭션이 필요한 시스템. 쿼리를 사용해 데이터를 집계할 필요가 있는 경우.
* 초기 프로토타입이나 기술 검토 용도로도 훌륭하지 못하다. 쿼리 패턴이 어떻게 바뀔지 알기 어렵고, 패턴이 바뀌게 된다면 칼럼 패밀리 설계도 바꿔야 하므로 생산성이 떨어진다.


# Chapter 11 : Graph

Entity와 Entity 사이의 관계를 저장할 수 있다. Entity는 Node라고도 하고 속성을 가진다. 그리고 Node는 애플리케이션의 객체 인스턴스라고 볼 수 있다. 
관계는 속성을 가질 수 있는 간선. 간선은 방향성을 가진다.

노드를 관계로 연결해 구조를 만들고, 구조가 만들어지면 노드 간에 존재하는 흥미로운 패턴을 찾을 수 있다. 데이터를 한 번 저장하고 관계를 이용해 다양항 방법으로 해석할 수 있다.
그래프에 대한 쿼리는 그래프 순회라고 한다. 노드나 간선을 변경하지 않고 순회 요건을 바꿀 수 있다는 점이 장점이다. 원하는 대로 그래프를 순회할 수 있기 때문이다. 
노드를 생성할 때 중요한 점은 ‘관계의 방향’이다. 노드가 두 개 이상 있으면 관계를 만들 수 있다. 또한 그래프 데이터베이스에서는 관계도 일급 시민이다. 대부분의 값을 관계로부터 유도할 수 있다. 관계는 타입, 시작 노드, 끝 노드, 관계 자신의 속성을 가질 수 있다. 관계 자신의 속성으로 언제 친구가 되었는지 노드 간 거리는 얼마나 되는지, 노드 사이에 어떤 측면이 공유되는지 등을 추가할 수 있다. 

대다수 그래프 데이터베이스 솔루션은 보통 다른 서버에 노드를 분산하는 것을 지원하지 않는다. 단일 서버 안에서 데이터는 항상 일관적이고, 특히 네오4J에서는 ACID를 완벽하게 지원한다. 트랜잭션을 통해 일관성을 보장하고, 홀로 존재하는 관계는 허용하지 않는다. 관계에는 항상 시작노드와 끝 노드가 있어야 하며, 노드는 연결된 관계가 없을 때에만 삭제할 수 있다.
네오4J는 ACID를 지원한다. 노드를 변경하거나 기존 노드에 관계를 추가하기 전에 트랜잭션을 시작해야 한다. 연산을 트랜잭션으로 감싸지 않으면 NotInTransactionException이 발생한다. 읽기 연산은 예외이다. success (X) - finish (O) 는 finish 시점에 트랜잭션을 롤백한다. success (O) - finish (X) 또한 커밋하지 않는다. success (O) - finish (O) 가 커밋된다. 
네오4J는 복제 슬레이브를 사용하는 방법으로 고가용성을 지원한다. 마스터와 슬레이브를 항상 동기화하는데 인피니트 그래프나 플록DB는 노드의 분산 저장을 지원한다. 네오4J는 현재 마스터 노드에 저장된 마지막 트랜잭션 아이디를 추적하는데 아파치 주키퍼 (ZooKeeper)를 사용한다. 
Gremlin 같은 쿼리 언어를 지원한다. 인덱싱 서비스를 이용해 노드의 속성에 인덱스를 달 수 있다. 마찬가지로 관계나 간선의 속성에도 인덱스를 달 수 있다. 특히 다양한 단계의 관계에 대해서 검색할 때 RDBMS보다 유용하다.

그래프 데이터베이스는 집합 지향이 아니라 관계 지향이므로 샤딩이 어렵다. 어떤 노드든 다른 노드와 관계될 수 있으며, 그래프 순회를 위해서는 관계된 노드를 같은 서버에 저장하는 것이 좋다. 노드가 서로 다른 장비에 위치하면, 그래프 순회 성능에 불리하다. 이런 한계에도 불구하고, 몇 가지 일반적인 기법이 있다. (짐 웨버 Jim Webber)

* 서버에 메모리를 충분하게 추가해 노드와 관계를 처리하는 작업 전체가 메모리에서 수행되도록 한다.
* 더 많은 읽기 전용 슬레이브를 추가하고 모든 쓰기는 마스터에서 처리한다. (이 방식은 MySQL 클러스터에서 이미 검증된 기법이고, 데이터 집합 크기가 단일 장비 메모리에서 처리하기엔 너무 크지만, 여러 장비에 복제해도 괜찮을 정도로 작은 경우에 유용)
* 데이터 집합 크기가 너무 커서 복제가 비현실적인 경우에는 도메인 지식을 이용해 애플리케이션에서 데이터를 분할(샤딩)할 수 있다.

적절한 사용 :
* 연결된 데이터 - SNS, 직원과 프로젝트, 단일 데이터베이스 내에서 서로 다른 도메인의 엔티티 사이의 곤계
* 라우팅, 디스패치, 위치기반 서비스 - 배달받는 위치와 배달부가 배달해야 하는 노드.
* 추천엔진 - 어떤 제품이 함께 구입되는지 혹은 함께 배송되는 지 등의 다양한 측면에서의 추천이 가능해진다.

적절하지 않은 사용 :
* 엔티티 전체 혹은 부분집한을 업데이트하고 싶을 때 


# Chapter 12 : Schema 전환

NoSQL에 대해서 논의할 때 스키마가 없는 특징을 강조하는 것이 최근 추세이다. 스키마 변경을 걱정하지 않고 도메인 설계에 집중할 수 있다는 것. 요구 사항 변경에 대해선 Agile Methods의 주목과 함께 부각되고 있다. 스키마 변경이 쉬워 개발자 생산성이 향상된다고 생각하겠지만, 스키마 전환에는 세심한 주의가 필요하다.

## From RDBMS to NoSQL 
RDBMS에서는 1. 객체와 객체 사이의 관계 2. 객체 에 대응되는 테이블을 만든다. 이렇게 만든 테이블과 관계에서 새로운 속성이 추가된다고 하면, 애플리케이션 단계와 DB 단계에서 전부 체크가 되어야 한다. 데이터베이스 변경 관리 프레임워크로 ‘DB디플로이’ 라는 툴을 사용한다.

## From Legacy to NoSQL
기존 데이터베이스로부터 모든 코드와 참조 데이터, 구조를 추출해 스크립트로 만들고 프로젝트의 기준선(baseline)으로 삼는다. 여기에는 트랜잭션 데이터가 포함되어서는 안된다. 중요한 방향 중 하나는 ‘하위 호환성’이 유지되어야 한다는 것이다. 그래서 변경에 대한 과도기를 두어 하위 호환성을 지킬 수 있다. 이를 위해 트리거, 뷰, 가상 칼럼 같은 임시 구조를 사용해 다른 애플리케이션에서 코드를 수정하지 않고도 DB 스키마와 필요한 데이터에 접근할 수 있게 해야 한다.

## NoSQL 데이터 저장소에서 변경
스키마가 없다는 말을 스키마에 대해 신경쓰지 않아도 된다는 말로 오해해선 안된다. 새로운 애플리케이션 코드에서 스키마 변경 전의 데이터도 해석하고, 데이터를 저장할 때 새로운 스키마에 맞게 저장할 수도 있다. 점증적 전환이라는 기법이고 긴 시간에 걸쳐 전환을 이룬다. 당연하게 과도기가 짧을수록 좋고 길어질수록 객체 설계가 복잡해진다. 데이터에 schema_version 필드를 두고 애플리케이션에서 적절히 선택하도록 할 수 있다.
모바일 애플리케이션에서는 거의 모든 버전의 스키마를 처리할 수 있어야 한다.


# Chapter 13 : 다중 저장소 지속성

각 데이터베이스는 다른 문제를 풀 수 있도록 설계되었다. 모든 요구 사항을 충족하는 하나의 데이터베이스란 없다. RDBMS에서도 OLAP과 OLTP 시스템의 요구 사항은 매우 다르다.
2006년 닐 포드(Neal Ford)가 “문제마다 이를 해결하는 데 유리한 언어가 있으므로, 이를 활용하기 위해 애플리케이션을 여러 언어로 작성해야 한다.”라는 생각을 표현하기 위해 폴리글랏 프로그래밍이란 용어를 만들었다. 전자상거래 시스템 (혹은 우리가 개발하는 시스템) 에서도 마찬가지이다. 여러 종류의 저장소를 사용하는 방법을 정의하기 위해 ‘다중 저장소 지속성’이란 용어를 사용한다.


# Chapter 14 : NoSQL을 넘어


# Chapter 15 : 데이터베이스 선정
